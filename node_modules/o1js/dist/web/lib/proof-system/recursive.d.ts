import { InferProvable } from '../provable/types/struct.js';
import { Provable } from '../provable/provable.js';
import { ProvableType } from '../provable/types/provable-intf.js';
import { Tuple } from '../util/types.js';
import { Proof } from './proof.js';
import { Bool } from '../provable/bool.js';
import { From } from '../../bindings/lib/provable-generic.js';
export { Recursive };
declare function Recursive<PublicInputType extends Provable<any>, PublicOutputType extends Provable<any>, PrivateInputs extends {
    [Key in string]: Tuple<ProvableType>;
}>(zkprogram: {
    name: string;
    publicInputType: PublicInputType;
    publicOutputType: PublicOutputType;
    privateInputTypes: PrivateInputs;
    rawMethods: {
        [Key in keyof PrivateInputs]: (...args: any) => Promise<{
            publicOutput: InferProvable<PublicOutputType>;
        }>;
    };
    maxProofsVerified: () => Promise<0 | 1 | 2>;
} & {
    [Key in keyof PrivateInputs]: (...args: any) => Promise<{
        proof: Proof<InferProvable<PublicInputType>, InferProvable<PublicOutputType>>;
    }>;
}): {
    [Key in keyof PrivateInputs]: RecursiveProver<InferProvable<PublicInputType>, PublicInputType, InferProvable<PublicOutputType>, PrivateInputs[Key]> & {
        if: ConditionalRecursiveProver<InferProvable<PublicInputType>, PublicInputType, InferProvable<PublicOutputType>, PrivateInputs[Key]>;
    };
};
type RecursiveProver<PublicInput, PublicInputType, PublicOutput, Args extends Tuple<ProvableType>> = PublicInput extends undefined ? (...args: TupleFrom<Args>) => Promise<PublicOutput> : (publicInput: From<PublicInputType>, ...args: TupleFrom<Args>) => Promise<PublicOutput>;
type ConditionalRecursiveProver<PublicInput, PublicInputType, PublicOutput, Args extends Tuple<ProvableType>> = PublicInput extends undefined ? (condition: Bool | {
    condition: Bool;
    domainLog2?: number;
}, ...args: TupleFrom<Args>) => Promise<PublicOutput> : (condition: Bool | {
    condition: Bool;
    domainLog2?: number;
}, publicInput: From<PublicInputType>, ...args: TupleFrom<Args>) => Promise<PublicOutput>;
type TupleFrom<T> = {
    [I in keyof T]: From<T[I]>;
};
